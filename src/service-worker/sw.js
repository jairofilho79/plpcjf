import { precacheAndRoute } from 'workbox-precaching';
import { registerRoute } from 'workbox-routing';
import { CacheFirst, NetworkFirst } from 'workbox-strategies';

// Precache files generated by vite-plugin-pwa
precacheAndRoute(self.__WB_MANIFEST);

const CACHE_NAME = 'pls-v3';
const RUNTIME_CACHE = 'pls-runtime-v3';
const LOUVORES_MANIFEST_URL = '/louvores-manifest.json';

let installProgress = { total: 0, current: 0 };

// === Sync metadata and guards ===
const META_BUCKET = 'pls-meta-v2';
const META_KEYS = {
  manifestHash: '/__meta__/manifest-hash',
  lastSyncAt: '/__meta__/last-sync-at',
  lastSummary: '/__meta__/last-summary'
};

let isSyncInProgress = false;
let isSyncCancelled = false;
let syncAbortController = null;

async function openMetaCache() {
  return caches.open(META_BUCKET);
}

async function getMeta(key) {
  const c = await openMetaCache();
  const res = await c.match(key);
  if (!res) return null;
  const text = await res.text();
  try { return JSON.parse(text); } catch (_) { return text; }
}

async function setMeta(key, value) {
  const c = await openMetaCache();
  const body = typeof value === 'string' ? value : JSON.stringify(value);
  await c.put(key, new Response(body, { headers: { 'content-type': 'application/json' } }));
}

async function sha256Hex(str) {
  const enc = new TextEncoder().encode(str);
  const buf = await crypto.subtle.digest('SHA-256', enc);
  return [...new Uint8Array(buf)].map(b => b.toString(16).padStart(2, '0')).join('');
}

// Get classification folder path
function getClassificationPath(classification) {
  const mapping = {
    'ColAdultos': 'ColAdultos/',
    'ColCIAs': 'ColCIAs/',
    'Adicionados': 'Adicionados/',
  };
  return mapping[classification] || 'Avulsos/';
}

// Helper function to decode base64 to UTF-8
function atobUTF8(base64) {
  const binaryString = atob(base64);
  const bytes = new Uint8Array(binaryString.length);
  for (let i = 0; i < binaryString.length; i++) {
    bytes[i] = binaryString.charCodeAt(i);
  }
  const decoder = new TextDecoder('utf-8');
  return decoder.decode(bytes);
}

// Returns path with leading slash, ex: "/assets/ColAdultos/arquivo.pdf"
function getLouvorRelPath(louvor) {
  try {
    const raw = louvor && (louvor.pdfId || louvor['pdfId']);
    if (raw && typeof raw === 'string') {
      let decoded = '';
      try {
        decoded = atobUTF8(raw).trim();
      } catch (_) {
        decoded = '';
      }
      if (decoded) {
        let path = decoded.replace(/^\/+/, '');
        try {
          if (path.includes('%')) {
            path = decodeURIComponent(path);
          }
        } catch (_) {}
        if (path.toLowerCase().startsWith('assets/')) {
          return `/${path}`;
        }
        if (/\.pdf$/i.test(path) && path.includes('/')) {
          return `/assets/${path}`;
        }
      }
    }
  } catch (_) {}
  return `/assets/${getClassificationPath(louvor.classificacao)}${louvor.pdf}`;
}

// Install event
self.addEventListener('install', (event) => {
  console.log('[SW] Installing service worker...');
  self.skipWaiting();
});

// Helper to precache PDFs in batches with cancellation support
async function precachePdfsWithCancel(louvores, startIndex) {
  if (isSyncCancelled) {
    console.log('[SW] Sync cancelled, stopping precache');
    return;
  }

  const BATCH_SIZE = 10;
  const endIndex = Math.min(startIndex + BATCH_SIZE, louvores.length);

  console.log(`[SW] Precaching batch ${startIndex + 1}-${endIndex} of ${louvores.length}`);

  const batch = louvores.slice(startIndex, endIndex);
  let successesThisBatch = 0;
  const cache = await caches.open(CACHE_NAME);

  await Promise.allSettled(
    batch.map(async (louvor) => {
      if (isSyncCancelled) return;
      
      const relPath = getLouvorRelPath(louvor);
      const localUrl = new URL(relPath, self.location.origin).href;
      const remoteUrl = new URL(relPath, 'https://plpcjf.org').href;

      let response = null;
      try {
        const r = await fetch(localUrl, { redirect: 'follow' });
        const ct = (r.headers.get('content-type') || '').toLowerCase();
        if (r.ok && !ct.includes('text/html')) {
          response = r;
        }
      } catch (_) {}

      if (!response) {
        try {
          const r2 = await fetch(remoteUrl, { redirect: 'follow' });
          const ct2 = (r2.headers.get('content-type') || '').toLowerCase();
          if (r2.ok && !ct2.includes('text/html')) {
            response = r2;
          }
        } catch (e2) {
          console.warn('[SW] Fallback failed for', relPath, e2);
        }
      }

      if (response) {
        try {
          await cache.put(localUrl, response.clone());
          successesThisBatch += 1;
        } catch (e3) {
          console.warn('[SW] Failed to cache response for', relPath, e3);
        }
      }
    })
  );

  installProgress.current += successesThisBatch;
  const clients = await self.clients.matchAll();
  clients.forEach(client => {
    client.postMessage({
      type: 'PROGRESS',
      progress: installProgress
    });
  });

  console.log(`[SW] Cached batch ${startIndex + 1}-${endIndex}`);

  // Continue with next batch if needed and not cancelled
  if (endIndex < louvores.length && !isSyncCancelled) {
    return new Promise(resolve => {
      setTimeout(() => {
        precachePdfsWithCancel(louvores, endIndex).then(resolve);
      }, 100);
    });
  }

  // Após finalizar todos os lotes, executa verificação do cache (apenas se não cancelado)
  if (!isSyncCancelled) {
    try {
      await verifyCachedPdfs(louvores);
    } catch (e) {
      console.warn('[SW] verifyCachedPdfs failed', e);
    }
  }

  return Promise.resolve();
}

// Wrapper para manter compatibilidade com código existente
async function precachePdfs(louvores, startIndex) {
  return precachePdfsWithCancel(louvores, startIndex);
}

async function verifyCachedPdfs(louvores) {
  const cache = await caches.open(CACHE_NAME);
  const BATCH_SIZE = 10;
  let verified = 0;
  let present = 0;
  const missingSamples = [];

  for (let i = 0; i < louvores.length; i += BATCH_SIZE) {
    const slice = louvores.slice(i, i + BATCH_SIZE);
    await Promise.allSettled(
      slice.map(async (louvor) => {
        const relPath = getLouvorRelPath(louvor);
        const localUrl = new URL(relPath, self.location.origin).href;
        const match = await cache.match(localUrl);
        verified += 1;
        if (match) {
          present += 1;
        } else if (missingSamples.length < 5) {
          missingSamples.push(relPath);
        }
      })
    );
  }

  const summary = { present, total: verified, missingSamples };

  const clients = await self.clients.matchAll();
  clients.forEach(client => {
    client.postMessage({
      type: 'VERIFY_SUMMARY',
      summary
    });
  });

  return summary;
}

async function syncAllPdfs() {
  if (isSyncInProgress) {
    console.log('[SW] Sync requested but already in progress; ignoring.');
    return;
  }
  isSyncInProgress = true;
  try {
    const resp = await fetch(LOUVORES_MANIFEST_URL, { cache: 'no-cache' });
    if (!resp || !resp.ok) {
      console.warn('[SW] Manifest fetch failed');
      return;
    }
    const manifestText = await resp.text();
    const manifestHash = await sha256Hex(manifestText);

    let louvores;
    try {
      louvores = JSON.parse(manifestText);
    } catch (e) {
      console.warn('[SW] Manifest JSON parse failed', e);
      return;
    }
    if (!Array.isArray(louvores) || louvores.length === 0) {
      console.warn('[SW] Manifest is empty or invalid');
      return;
    }

    const summaryBefore = await verifyCachedPdfs(louvores).catch(() => null);
    const storedHash = await getMeta(META_KEYS.manifestHash);
    const allPresent = summaryBefore && summaryBefore.present === summaryBefore.total;

    if (storedHash === manifestHash && allPresent) {
      console.log('[SW] Sync skipped (manifest unchanged and all items present).');
      return;
    }

    installProgress = { total: louvores.length, current: 0 };
    await precachePdfs(louvores, 0);

    const summaryAfter = await verifyCachedPdfs(louvores).catch(() => null);

    await setMeta(META_KEYS.manifestHash, manifestHash);
    await setMeta(META_KEYS.lastSyncAt, new Date().toISOString());
    if (summaryAfter) await setMeta(META_KEYS.lastSummary, summaryAfter);
  } catch (e) {
    console.warn('[SW] syncAllPdfs failed', e);
  } finally {
    isSyncInProgress = false;
  }
}

// Sync filtered PDFs based on category filters
async function syncFilteredPdfs(filters, louvoresArray) {
  if (isSyncInProgress) {
    console.log('[SW] Sync requested but already in progress; ignoring.');
    return;
  }
  
  isSyncInProgress = true;
  isSyncCancelled = false;
  syncAbortController = new AbortController();
  
  try {
    // Filtrar louvores baseado nas categorias selecionadas
    let filteredLouvores = louvoresArray;
    if (filters && filters.length > 0 && !filters.includes('ALL')) {
      filteredLouvores = louvoresArray.filter(l => 
        l.categoria && filters.includes(l.categoria)
      );
    }
    
    if (filteredLouvores.length === 0) {
      console.log('[SW] No louvores match the selected filters');
      return;
    }
    
    // Verificar quais PDFs já estão em cache
    const cache = await caches.open(CACHE_NAME);
    const toDownload = [];
    
    for (const louvor of filteredLouvores) {
      if (isSyncCancelled) break;
      const relPath = getLouvorRelPath(louvor);
      const localUrl = new URL(relPath, self.location.origin).href;
      const match = await cache.match(localUrl);
      if (!match) {
        toDownload.push(louvor);
      }
    }
    
    // Enviar informação de PDFs já existentes
    const clients = await self.clients.matchAll();
    clients.forEach(client => {
      client.postMessage({
        type: 'CACHE_CHECK_COMPLETE',
        alreadyCached: filteredLouvores.length - toDownload.length,
        toDownload: toDownload.length,
        total: filteredLouvores.length
      });
    });
    
    // Baixar apenas os que faltam
    if (toDownload.length > 0 && !isSyncCancelled) {
      installProgress = { total: toDownload.length, current: 0 };
      await precachePdfsWithCancel(toDownload, 0);
    }
    
    // Verificar cache final (apenas se não cancelado)
    if (!isSyncCancelled) {
      const summaryAfter = await verifyCachedPdfs(filteredLouvores).catch(() => null);
    }
    
  } catch (e) {
    console.warn('[SW] syncFilteredPdfs failed', e);
  } finally {
    isSyncInProgress = false;
    isSyncCancelled = false;
    syncAbortController = null;
  }
}

self.addEventListener('activate', (event) => {
  console.log('[SW] Activating service worker...');
  event.waitUntil(
    caches.keys()
      .then(cacheNames => {
        return Promise.all(
          cacheNames
            .filter(name => name !== CACHE_NAME && name !== RUNTIME_CACHE && !name.startsWith('pls-meta'))
            .map(name => {
              console.log('[SW] Deleting old cache:', name);
              return caches.delete(name);
            })
        );
      })
      .then(() => {
        return self.clients.claim();
      })
      .catch(error => {
        console.error('[SW] Activate failed:', error);
      })
  );
});

  // Message handler
  self.addEventListener('message', (event) => {
    console.log('[SW] Received message:', event.data?.type, event.data);
    
    if (event.data && event.data.type === 'SKIP_WAITING') {
      self.skipWaiting();
    }
    if (event.data && event.data.type === 'SYNC_PDFS') {
      event.waitUntil(syncAllPdfs());
    }
    if (event.data && event.data.type === 'SYNC_PDFS_FILTERED') {
      console.log('[SW] Starting filtered sync with', event.data.filters?.length || 0, 'filters and', event.data.louvores?.length || 0, 'louvores');
      event.waitUntil(syncFilteredPdfs(event.data.filters, event.data.louvores));
    }
    if (event.data && event.data.type === 'CANCEL_SYNC') {
      isSyncCancelled = true;
      if (syncAbortController) {
        syncAbortController.abort();
      }
      console.log('[SW] Sync cancellation requested');
    }
  });

self.addEventListener('periodicsync', (event) => {
  if (event.tag === 'sync-pdfs') {
    event.waitUntil(syncAllPdfs());
  }
});

console.log('[SW] Service worker script loaded');

